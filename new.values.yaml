---
# -- Nom de votre application
applicationName: "bloomz-3b-retriever-v2-dev"
# -- Contexte de votre application (si / laisser vide)
context: ""
# -- Code Boite de votre application
codeBoite: "x260"
# -- Code Efs de votre application
codeEfs: 99
# -- Environnement de votre application (val/rec/hml/prd)
arkeaEnv: 'rec'
## - Nom du profile (spring , WAR_ENV à charger au démarrage de l'application)
profile: "REC-GCP"


# -- healthcheck url /tech/instancestatus par défaut
healthcheckUrl : "/ping"
# -- Activation de la collecte des metriques
monitoring: false

##############################################################################
# metrics permet l'exposition de métriques au format Prometheus
##############################################################################
metrics:
  # -- active l'exposition de métriques
  enabled: true
  # -- URL relative au contexte pour exposer les métriques prometheus
  endpoint: metrics/
  # -- refresh : temps de rafraichissement des métriques
  refresh: "30s"

##############################################################################
# image permet de configurer les images docker de la release
##############################################################################
image:
  # -  chemin vers l'image docker, est provisionné automatiquement dans la CD standard PaaS
  repository: docker-registry.s.arkea.com/creditmutuelarkea/llm-inference
  # -- politique de pull de l'image parmi :<br>
  # - Always : Kubernetes fera un pull de l'image docker au démarrage du container dans le pod<br>
  # - IfNotPresent : Kubernetes ne fera le pull de l'image que si elle n'existe pas déjà sur le node<br>
  # - Never : Kubernetes ne fera jamais le pull de l'image<br>
  pullPolicy: IfNotPresent
  # -- tag de l'image à provisionner, est provisiionné automatiquement dans la CD standard Paas
  tags: ["pr-5"]
  # -- pour changer la command du container
  args: [ "--model", "cmarkea/bloomz-3b-retriever-v2", "--port", "8080", "--task", "EMBEDDING"]


# -- port d'exposition du container applicatif
containerPort: 8080

# -- (array) permet de fournir des variables d'environnement au container applicatif<br>
# <pre>env:<br>
# - name: ENV_TEST<br>
#   value: "15"<br>
# - name: DB_PARAMETRES_SAE_PASSWORD<br>
#   valueFrom:<br>
#     secretKeyRef:<br>
#       name: db-parametres-sae<br>
#       key: password<br></pre>
env:
  - name: HUGGING_FACE_HUB_TOKEN
    valueFrom:
      secretKeyRef:
        name: hugging-face-hub-token
        key: token
  - name:  RUST_BACKTRACE
    value: "full"
  - name: TRANSFORMERS_CACHE
    value: "/usr/app/.cache"

# - DÉPRÉCIÉ - permet de fournir une configmap aux applications catalyst<br>
# Le choix a été fait de conserver le fonctionnement par fichiers yaml internes<br>
# à l'applicatif et de permettre la surcharge par variables d'environnement<br>
# pour palier au problème de rebuild nécessaire s'il y'a une modification à<br>
# apporter à la configuration <br>
# voir values.yaml pour plus de détails
config:
  loadConfigFromFile: true
  # -- Voir la conf Catalyst
  # catalyst:
  #   warm:
  #     enabled : true
  #     port : 8080
  #   apiregistry:
  #     enabled : false
  #   app:
  #     env : *env
  #   artimon:
  #     activate : false
  #     include : in.*,out.*,func.*
  #   status:
  #     min-monitored-instances : 1
  #   security:
  #     idp:
  #       enabled : false
  # spring:
  #   main:
  #     lazy-initialization : false
  #   session:
  #     store-type : none

##############################################################################
##configmap
## Permet de définir sa configmap, qui sera montée au déploiement
##############################################################################

##############################################################################
## pvc permet de déclarer un vol persistant sur le container
##############################################################################
pvc:
  enabled: true
  name: "bloomz-3b-retriever-v2-dev"
  finalizers:
  - kubernetes.io/pvc-protection
  accessModes:
  - ReadWriteOnce
  storageSize: 32Gi
  storageClassName: standard-rwo-cmek
  mountPath:
    - "/data"
    - "/tmp"

##############################################################################
## kafka permet de configurer le client mtls via istio
##############################################################################
kafka:
  # -- Permet d'activer l'accès au service Kafka associé à votre déploiement ( note : pensez a configurer votre valeur kafkaEnv, voir README )
  enabled: false
  cluster:
      # -- Nom du cluster kafka à joindre (kafka-business/kafka-technical) ( pour kafka-business, l'url de bootstrap sera kafka-business.arkea-system:9092 )
    - name: 'kafka-business'
      # -- Nom du user kafka tel que défini dans go/kafkaconf (exemple : 0035.exempleapi)
      user: 'xxxx.appli'

##############################################################################
# arksec active la gestion des secrets par arksec
##############################################################################
arksec:
  # -- active ou non la gestion des secrets par arksec
  enabled: false
  # -- nom du cluster k8s tel que défini dans arksec
  clusterName: "none"
  # -- temps de rafraichissement du token client récupéré auprès de arksec
  refreshInterval: "24h"
  # -- url vers arksec
  baseUrl: "https://arksec.hml.s.arkea.com:8443"
  # -- certificat de l'autorité en base64 pour la validation https (par défaut: arkea-ca)
  # @default -- se referer au fichier values.yaml
  caBundle: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tDQpNSUlFNmpDQ0E5S2dBd0lCQWdJRUVBQUx4akFOQmdrcWhraUc5dzBCQVFzRkFEQ0JrakVMTUFrR0ExVUVCaE1DDQpSbEl4RVRBUEJnTlZCQWdUQ0VKeVpYUmhaMjVsTVJvd0dBWURWUVFIRXhGTVpTQlNaV3hsWTNFdFMyVnlhSFZ2DQpiakVPTUF3R0ExVUVDaE1GUVZKTFJVRXhFekFSQmdOVkJBc1RDa0ZTUzBWQkxVUkZXRlF4RVRBUEJnTlZCQU1UDQpDRUZ5YTJWaElFTkJNUnd3R2dZSktvWklodmNOQVFrQkZnMXdhMmxBWVhKclpXRXVZMjl0TUI0WERUSXhNRFF4DQpOVEE1TVRreU1Wb1hEVEk0TURReE16QTVNVGt5TVZvd0tURW5NQ1VHQTFVRUF4TWVWbUYxYkhRZ1lYSnJaV0VnDQpRMEVnYVc1MFpYSnRaV1JwWVhSbElFNHlNSUlDSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQWc4QU1JSUNDZ0tDDQpBZ0VBNTdrKzFURG5YeDBia1J6RVpUSTQwYnVFSnl5QTgrcEd3cVRGNkNCYnVJNms3dW5TK1hWS0h3RGVjbnhmDQp3YjYycHdUWC9KR0orUkNBWS9aWkhIYmpXbk5iQkxGaGQxVHp5U0owNlNPMmxIRDRUbDRTWjZkNERVN1VmZGh2DQprcnRmcEthWTI2TVk1c1RWL213MkJ5K3puWEJRUDNybHlabkpJYmN4cW81RmZzQjVtSHRFY2pDMzZsUkh2bHZ4DQozRlhxSmdaRXM0cTRKcXlFTmxNTDUzbmxvSTZGSkU1WDNqalBMaW1WWDREZ2V6eXVKZDlFUHdmQnEwMllzV0VQDQpIZmtUbit5MDRQbzVWaDNBSmpXS1AvSTU2Mk5RaWRyaFFNT3RURTl4S09GZTNPSEpEbGdjSUJoSXdaRWZsaFArDQpRV3NZSytqV1JTb2dIdTUvYVhPWVBndU04eTdlWE4yaUhWV0JyWWMxUDRWMzE5aytWVG9FQSt0ODQzeGI0Q2xDDQp0bkFpZHg2MllUUVViNU1uM2ZOUzhHb2FCNXJvcnAxVGxlb2NybWhmMDRXOS9pUHM2VnFlV0Y0OSszcDAxNGwzDQp4LzVXcnhUcXM1eFZwSmM3OEF0M05Ub0xzYzZyTkFBMU5Mb2w4NVB3SllxUWdza2ZiSWMxZU42QW84d3A2Q0FUDQpJT3dLaWczUEtKZGdZN3Qzc0orNVdaTVdCdEpPc204K1dkTldDSlE2bmJkb1A1TitvaGxRdHhCdy9VYmx0b2xzDQp6bEV0ekxCdDdYdm1lSytjTmxxa3VkRWRaVVVvWUVVT3VPaEROWWNVN0tCNGNSSVo0M000bmNDU0pYUnpsK3lCDQowV0FEMnJtNGp1N1hOaDVoaGxvZm5MR0t4ZE9ua1FrU3Q0YVVwdmRmNEJ2Y0NqTUNBd0VBQWFPQnJ6Q0JyREFkDQpCZ05WSFE0RUZnUVVHNzBnUHNNbGRzdVR1WWNWazhySksxcElhQnd3SHdZRFZSMGpCQmd3Rm9BVUdOUzIzSUY4DQp6eGE4RmhTUnVOSU00S2xoNDl3d0R3WURWUjBUQVFIL0JBVXdBd0VCL3pBT0JnTlZIUThCQWY4RUJBTUNBWVl3DQpTUVlEVlIwZkJFSXdRREErb0R5Z09vWTRhSFIwY0RvdkwyTnliQzV6TG1GeWEyVmhMbU52YlRvNE1EZ3dMMkZ5DQphMlZoUTBGZlpHSXlOMlJtWm1Wa1l6QmtNbVUwTkM1amNtd3dEUVlKS29aSWh2Y05BUUVMQlFBRGdnRUJBQklwDQpQR0NPUjRHZDZCMWphdWV0UEhpQ0NaaVhybGZNcGhQTkc4RzZDNkNHek5sTGNsUGNXTCs5OU8ydDJRWWE4ak4vDQpZR3k1MGxNVUgwalk1RWFtREQzYjNCOGNUazIrdWlGc1VyeWIwWjlvNDIzZS80d3MxL0trL1lNZmNMaEhOWmV1DQpaNTVxeTJIdmx3eS9JREdpQjZTRTFrZm9OOVpqaXArTGw1NkZoRG16bEFZcVBaYmlPUnA0cEwrbndUd240REZBDQpCUEZWWkd5QTREN0s3K3BQdEJCNjRabEZ1cHdnZENiL0VhTG5Vamk0R2VBRHcreXFZWm9TRXowd045aE1scWFpDQoxQzdqeEdmZklsa0dLeXZkOWNvZGs3SmtMK2ZOL2FnejI4cmtkaUhNRzdHZ1QxTGw5UUxMbk5nTG1tMlZCdXNxDQp2bHdrWE8zUWxiTG4xQU1Rc2d3PQ0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQ0KLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tDQpNSUlFcERDQ0E0eWdBd0lCQWdJSkFOc24zLzdjRFM1RU1BMEdDU3FHU0liM0RRRUJDd1VBTUlHU01Rc3dDUVlEDQpWUVFHRXdKR1VqRVJNQThHQTFVRUNCTUlRbkpsZEdGbmJtVXhHakFZQmdOVkJBY1RFVXhsSUZKbGJHVmpjUzFMDQpaWEpvZFc5dU1RNHdEQVlEVlFRS0V3VkJVa3RGUVRFVE1CRUdBMVVFQ3hNS1FWSkxSVUV0UkVWWVZERVJNQThHDQpBMVVFQXhNSVFYSnJaV0VnUTBFeEhEQWFCZ2txaGtpRzl3MEJDUUVXRFhCcmFVQmhjbXRsWVM1amIyMHdIaGNODQpNVFF4TURJd01UVTBPREUyV2hjTk16UXhNREUxTVRVME9ERTJXakNCa2pFTE1Ba0dBMVVFQmhNQ1JsSXhFVEFQDQpCZ05WQkFnVENFSnlaWFJoWjI1bE1Sb3dHQVlEVlFRSEV4Rk1aU0JTWld4bFkzRXRTMlZ5YUhWdmJqRU9NQXdHDQpBMVVFQ2hNRlFWSkxSVUV4RXpBUkJnTlZCQXNUQ2tGU1MwVkJMVVJGV0ZReEVUQVBCZ05WQkFNVENFRnlhMlZoDQpJRU5CTVJ3d0dnWUpLb1pJaHZjTkFRa0JGZzF3YTJsQVlYSnJaV0V1WTI5dE1JSUJJakFOQmdrcWhraUc5dzBCDQpBUUVGQUFPQ0FROEFNSUlCQ2dLQ0FRRUEyS0QrOEhFZUpNN0NDbHlWWlhYY0tRR0w1aW00bDAveW80R09XRllaDQpBdnY0OE8xRUo1d2dOb3p5OWlPWkIvUjBtNDBoc2hFd2hrd1VzU1hERnV2eCtsRStaL3FWelVGT01MTHQyZGErDQpXMTY3NFZ0WGJ2K3pBWVo3UG44Z29uUTlYbnBETmx1WW5TSERzOEdKUUxqRkxaNS83MGEwZm12d3VWOXhUb3Y4DQprcFpaakFqYklPSVBwR3VVNytLSjI4bHpoVjJrZzNhKzRDNHpFZk5YQmJKSWR2TllRamJMcDBFOUJIb3dmNnlDDQpOSldEanlVdkw3RmF3U0lBUU9lQWw0YUpnOU5kanZNTFBOQkxSYW44WHVtQ1FCa3BqVldSRm5jdFRYRDlVcXM4DQpkbU1jV090YjJsVE1mWG9sRkRMRkJSa3pGMklML0dadWxyaFhlcHRHc3NjSVhRSURBUUFCbzRINk1JSDNNQjBHDQpBMVVkRGdRV0JCUVkxTGJjZ1h6UEZyd1dGSkc0MGd6Z3FXSGozRENCeHdZRFZSMGpCSUcvTUlHOGdCUVkxTGJjDQpnWHpQRnJ3V0ZKRzQwZ3pncVdIajNLR0JtS1NCbFRDQmtqRUxNQWtHQTFVRUJoTUNSbEl4RVRBUEJnTlZCQWdUDQpDRUp5WlhSaFoyNWxNUm93R0FZRFZRUUhFeEZNWlNCU1pXeGxZM0V0UzJWeWFIVnZiakVPTUF3R0ExVUVDaE1GDQpRVkpMUlVFeEV6QVJCZ05WQkFzVENrRlNTMFZCTFVSRldGUXhFVEFQQmdOVkJBTVRDRUZ5YTJWaElFTkJNUnd3DQpHZ1lKS29aSWh2Y05BUWtCRmcxd2EybEFZWEpyWldFdVkyOXRnZ2tBMnlmZi90d05Ma1F3REFZRFZSMFRCQVV3DQpBd0VCL3pBTkJna3Foa2lHOXcwQkFRc0ZBQU9DQVFFQU9lUFpKdWJHamRlbS9ka2VEQzlPZXk4aG5tNlNrOEpwDQpzVzVaMDBOdjZyK2VuUkwvWnZnNmxvTGQ0R0FFNmFyV29Uc2xFSDJaVEFnZm5oWGNJOUJ5UFJDeG1lQlhrWldSDQpPanU2OEQ3QmxiSWlhMkRWNkhXV3JLVEU2QS9ra1VRK0FGaWdRVUE0Nk9uL1NTcUp4MjVsMjVaOXRvb2U3WlRmDQpXSWFVM1h4TkV4dmNmNVRxUHdBOTdmV0hyVEZCOUFFaFhqQS9BbmMvRUJSaVZsK2RtZkN6M2Vjdm14YzZxZWVKDQpnM1hCSllhQXFjNUV3R1VNYW40UktjcUcyZzhGSCtmNlBGWFQ5TG1KZnVWN3BPejQvWnN5N1BqbS96WWphVDVDDQp1bmViaWZLems2ZlNrRXhzRDdXL3FMd0dMZStPcHhZTlhQajFYeGZ0WWNxVVQ3TGM0dXRmOUE9PQ0KLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQ0K

# -- serviceEntries permet de configurer l'accès à des services externes<br>
# La chart propose une simplification de la ref ci-dessous<br>
# ref: https://istio.io/latest/docs/reference/config/networking/service-entry/#ServiceEntry<br>
# <pre>serviceEntries:<br>
#   - protocol: HTTPS  # doit être parmi HTTP, HTTPS, GRPC, HTTP2, MONGO, TCP, TLS"<br>
#     port: 443  # Port de connexion<br>
#     hosts:  # Liste des hosts concernés par ce protocole / port<br>
#       - host1.domain.com<br>
#       - host2.domain.org<br>
#   - protocol: HTTP<br>
#     port: 8080<br>
#     hosts:<br>
#       - host3.domain.com</pre>
# Cet exemple autorise les accès vers https://host1.domain.com:443, https://host2.domain.org:443 et<br>
# http://host3.domain.com:8080<br>
serviceEntries:
  - hosts:
    - "huggingface.co"
    - "cdn-lfs.huggingface.co"
    - "cdn-lfs-us-1.huggingface.co"
    - "hf.co"
    - "cdn-lfs.hf.co"
    - "cdn-lfs-us-1.hf.co"
    protocol: HTTPS
    port: 443

# -- Activer cette option fera valider le jwt par les clés apigee au niveau du proxy envoy<br>
# Une RequestAuthentication sera créée par release
validateJwt: false

authorizationPolicies:
  # -- comportement par défault. Autorise tous les flux vers l'applicatif
  allowAll: true
  # -- Permet de customiser l'autorization policy de type allow. Il est nécessaire de passer allow-all à false pour activer la customisation.<br>
  # Correspond à un tableau de []Rule (https://istio.io/latest/docs/reference/config/security/authorization-policy/#Rule)
  # Plus d'exemple sur https://arkeastore.intra.arkea.com/catalog/default/Component/kapla/docs/actes_techniques_dev_ops/istio/istio_authorization_policies/
  allowAdvanced: []

##############################################################################
## loadBalancing permet de configurer le comportement du load balancing
## en particulier pour activer les sticky sessions
##############################################################################
loadBalancing:
  # -- 3 modes disponibles : simple | stickysession | advanced<br>
  # laisser simple par défault.<br>
  # stickysession si l'application est stateful<br>
  # advanced pour les cas avancés (se rapprocher de l'équipe kapla si besoin)
  mode: simple
  stickysession:
    # -- spécifier le cookie de session
    cookie: JSESSIONID
  # -- ConsistentHashLB https://istio.io/latest/docs/reference/config/networking/destination-rule/#LoadBalancerSettings-ConsistentHashLB
  advanced:
    useSourceIp: true

##############################################################################
## (temporaire) redis:
##   enabled : Permet d'activer un service Redis associé à votre déploiement
##   activé par défaut
##
## La fonctionnalité est temporaire en attendant une solution Data (memorystore, redis enterprise, opérateur...)
##############################################################################
redis:
  # -- Permet d'activer un service Redis associé à votre déploiement
  enabled: true
  resources:
    limits:
      cpu: '200m'
      memory: '500Mi'
    requests:
      cpu: '200m'
      memory: '500Mi'

# -- imagePullSecrets spécifie la liste des secrets à utiliser pour l'accès à la registry (artifactory ne les nécessite pas)
# -- cf doc kubernetes https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/#create-a-pod-that-uses-your-secret
imagePullSecrets: []

# -- nameOverride sert à surcharger le nom de l'application dans le nom de base <chart>.<nom application>
nameOverride: ""

# -- fullnameOverride sert à surcharger le nom de base complet (<chart>.<nom application>)
fullnameOverride: ""

# -- serviceAccount permet de créer ou lier un serviceAccount kubernetes à l'application
serviceAccount:
  # -- Specifies whether a service account should be created
  create: false
  # -- Annotations to add to the service account
  annotations: 
  # -- The name of the service account to use.
  # -- If not set and create is true, a name is generated using the
  # -- fullname template
  name: ""

# -- secretVolumes permet de créer un volume à partir d'un Secret Kubernetes.<br>
# <pre>secretVolumes:<br>
#  - name: "" # Nom du volume<br>
#    path: "" # Chemin de montage du volume<br>
#    secretName: "" # Nom du Secret associé<br></pre>
secretVolumes: []

# - podAnnotations permet de fournir des annotations kubernetes au pod<br>
# voir documentation kubernetes https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
podAnnotations: {}

# -- détermine le contexte de sécurité d'exécution du pod<br>
# par défaut, le pod ne sera pas exécuté en tant que root<br>
# Description sur https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
podSecurityContext:
  runAsNonRoot: false
  # fsGroup: 1337 #useful if writing with fuse GCS is required
  # secompProfile:
  # seLinuxOptions:

# -- SecurityContext détermine le contexte de sécurité d'exécution du container<br>
# Par défaut on fait tourner le container avec aucune capability et un filesystem root en lecture seule<br>
# Description sur https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container<br>
securityContext:
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: false

service:
  # -- type du service, https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
  type: ClusterIP
  # -- port d'écoute du service
  port: 8080

##############################################################################
## autoscaling fournit les informations de mise à l'échelle de l'application
##
## Par défaut l'autoscaling est activé, fournit un réplica de l'application et peut provisionner jusqu'à 10 réplicas
## si le cpu dépasse 80% d'utilisation
##############################################################################
## autoscaling:
##   enabled : actif si true
##   minReplicaCount :
##   maxReplicaCount :
##   triggers:
##   - type: cpu
##     metricType: Utilization
##     metadata:
##       value  :
##   - type: memory
##     metricType: Utilization
##     metadata:
##       value :
##   - type: cron :
##     metadata:
##       timezone: timezone
##       start: crontab permettant de définir le début de la période
##       end: crontab permettant de définir la fin de la période
##       desiredReplicas: entre start et end, nombre de replicas désiré, sinon ça sera minReplicaCount
##############################################################################
autoscaling:
  # -- active l'autoscaling
  enabled: false
  # -- nombre de replicas au déploiement de l'application
  minReplicaCount: 0
  # -- nombre maximum de réplicas pour l'application
  maxReplicaCount: 1
  triggers:
  - type: cpu
    metricType: Utilization
    metadata:
      # -- seuil de consommation de cpu à atteindre pour provisionner un nouveau réplica
      value: "80"
  - type: memory
    metricType: Utilization
    metadata:
      # -- seuil de consommation de mémoire à atteindre pour provisionner un nouveau réplica
      value: "80"
  # --  permet de baisser le nombre de réplica sur une période donnée
  - type: cron
    metadata:
      timezone: Europe/Paris
      # -- tous les jours à 08h00
      start: 0 8 * * *
      # -- tous les jours à 19h00
      end: 0 19 * * *
      # -- entre start et end, j'aurais desiredReplicas, sinon ça sera minReplicaCount
      desiredReplicas: "1"

# -- permet de déployer l'application sur un noeud qui porte les labels défini dans la map
nodeSelector:
  arkea.com/node-type: null
  cloud.google.com/gke-accelerator: nvidia-l4
  node_pool: apps-on-demand-l4-time-sharing-nvidia-l4

# -- tolerations est la liste des tolerations à appliquer au pod. ref https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/#concepts
tolerations :
  - key: nvidia.com/gpu
    operator: Equal
    value: present
    effect: NoSchedule
  - key: arkea.com/usage
    operator: Equal
    value: apps-on-demand-l4-time-sharing
    effect: NoSchedule

# -- peuple automatiquement l'affinité et les topologySpreadConstraint des déploiements.<br>
# la surcharge de `affinity` ou de `topologySpreadConstraints` écrasera les valeurs positionnées automatiquement<br>
# L'utilisation de ce paramètre NE DÉFINIT PAS les minimumReplicas à 2. Referer vous à l'élément `autoscaling` de la chart/
enableHighAvaibility: false

# -- affinity sert à fournir des règles d'affinité. ref https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
affinity : {}

# -- manière de distribuer les pods d'un déploiement, ref https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/
topologySpreadConstraints: []

# -- définition de la mémoire et du CPU allouée au Pod<br>
# la request est valeur garantie pour le pod<br>
# la limit est la valeur que peut utiliser le pod si les ressources disponibles sur le noeud. Elle est donc non garantie<br>
# pour la mémoire, il est important de laisser la requests == limits<br>
# il est également possible de demander du stockage ephémère à l'aide de `requetsEphemeral: "1Gi"`<br>
# et de la limit GPU avec `limitsGpu: "1"`
resources:
  requestsMemory: 12Gi
  limitsMemory: 12Gi
  limitsGpu: 1

# --(object) permet de définir les niveaux de log log4j2 (fichier présent dans /config/log4j2.xml
# liste de clefs-valeurs où la clé est la classe ou le package et la valeur<br>
# le niveau de log<br>
#<pre>logger:<br>
#  levels:<br>
#    - package: com.arkea.monappli<br>
#      level: DEBUG<br>
#    - package: com.arkea.catalyst<br>
#      level: WARN<br>
#    - package: root<br>
#      level: INFO<br></pre>
logger:

gcs:
  # -- active la fonctionnalité de monter un bucket en tant que filesystem dans les pods
  enabled: false
  buckets:
    # -- nom du volume à monter, différent pour chaque bucket à monter
  - volumeName: gcs-fuse-csi-ephemeral
    # -- nom du bucket à monter
    bucketName: my-big-bucket
    # -- path dans lequel le bucket sera monté
    mountPath: /data
    # -- mettre à false pour permettre l'écriture sur le bucket. Attention : le service account doit avoir les droits en écriture sur le bucket
    readOnly: true

# -- https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
livenessProbe: {}
# -- https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
readinessProbe: {}
# -- https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
startupProbe: {}

##############################################################################
## public_exposition permet de fournir une configuration d'exposition public 
##############################################################################
public_exposition:
  enabled: false
  external_ip_address_name: "cdn-static" #The global static ip address name. It's a reference.
  certificate_name: "foobar200x-arkea-gcp-net"
  useGoogleManagedCertificate: false
  hosts: ["foobar2000.arkea-gcp.net", "foobar3000.arkea-gcp.net"]
  cdn:
    #If set to true, Cloud CDN is enabled for this Ingress backend.
    enabled: true
    cachePolicy:
      #If set to true, requests to different hosts are cached separately.
      includeHost: true
      #If set to true, HTTP and HTTPS requests are cached separately.
      includeProtocol: true
      #If set to true, query string parameters are included in the cache key according to queryStringBlacklist
      #or queryStringWhitelist. If neither is set, the entire query string is included.
      #If set to false, the entire query string is excluded from the cache key.
      includeQueryString: false
      #Specify a string array with the names of query string parameters to exclude from cache keys.
      #All other parameters are included. You can specify queryStringBlacklist or queryStringWhitelist, but not both.
      #queryStringBlacklist: ["xx", "aa"]
      #Specify a string array with the names of query string parameters to include in cache keys.
      #All other parameters are excluded. You can queryStringBlacklist or queryStringWhitelist, but not both.
      #queryStringWhitelist: ["xx", "aa"]
    #bypassCacheOnRequestHeader contains configuration for how requests
    #containing specific request headers bypass the cache, even if the content
    #was previously cached.
    #bypassCacheOnRequestHeaders:
      #headerName: foobar
    #see https://cloud.google.com/cdn/docs/caching#cache-modes
    #cacheMode: CACHE_MODE
    #https://cloud.google.com/cdn/docs/using-ttl-overrides
    # clientTtl: CLIENT_TTL
    # defaultTtl: DEFAULT_TTL
    # maxTtl: MAX_TTL
    #https://cloud.google.com/cdn/docs/using-negative-caching
    #negativeCaching: true|false
    # negativeCachingPolicy:
    #   code: NEGATIVE_CACHING_CODE
    #   ttl: NEGATIVE_CACHING_TTL
    #https://cloud.google.com/cdn/docs/caching#request-coalescing
    #requestCoalescing: REQ_COALESCING
    #https://cloud.google.com/cdn/docs/serving-stale-content
    #serveWhileStale: SERVE_WHILE_STALE
    #https://cloud.google.com/cdn/docs/using-signed-urls#optionally_customizing_the_maximum_cache_time
    # signedUrlCacheMaxAgeSec: SIGNED_MAX_AGE
    #https://cloud.google.com/cdn/docs/using-signed-urls#creatingkeys
    # signedUrlKeys:
    #   keyName: KEY_NAME
    #   keyValue: KEY_VALUE
    #   secretName: SECRET_NAME
  customResponseHeaders:
    - "hsts: True"
    - "hsts-include-subdomains: True"
    - "hsts-max-age: 28800"
    - "Strict-Transport-Security: max-age=31536000; includeSubDomains"
    - "X-Frame-Options: SAMEORIGIN"
    - "X-Content-Type-Options: nosniff"
    - "X-XSS-Protection: 1; mode=block"
    - "Referrer-Policy: no-referrer-when-downgrade"
    - "Content-Security-Policy: upgrade-insecure-requests;"
    - "Permissions-Policy: geolocation 'none'; microphone 'none'"
    - "Expect-CT: enforce, max-age=8640"
    - "Access-Control-Allow-Origin: *"
  securityPolicy:
    name: backend-static-assets
  ## Configure backend custom health Check (https://cloud.google.com/kubernetes-engine/docs/how-to/ingress-configuration#direct_health)
  ## requestPath is configured from healthcheckUrl value and port from service.port value
  # healthCheck:
  #   checkIntervalSec: INTERVAL
  #   timeoutSec: TIMEOUT
  #   healthyThreshold: HEALTH_THRESHOLD
  #   unhealthyThreshold: UNHEALTHY_THRESHOLD
  #   type: TYPE


##############################################################################
## private_exposition permet de fournir une configuration d'exposition de l'application
## par ingress istio
##############################################################################
##   canary:
##     enabled : active le mode canary (true ou false)
##     alpha:
##       version : version de l'image canary
##       rule : Regle de Match Istio, voir doc istio
##         - match:
##             - headers:
##                 end-user:
##                   exact : jason
##   abrouting:
##     enabled : Active le mode ABRouting (true ou false)
##     beta:
##       version : version du mode ABRouting
##       weight : Poids de l'ABRouting
##############################################################################
private_exposition:
  enabled: true
    # -- Protocole
  proto: https
  # -- Nom du host de votre application http://host.domain Votre Nom de domain est issu du cluster
  host: bloomz-3b-retriever-v2-dev
  # -- Nom du domain de votre application http://host.domain Le nom de domaine sera set par les appsets argocd en parametre
  domain: l00001208-e99-354.rec.cl1.arkea.com
  # -- cname : url d'exposition exposé aux utilisateurs monapp-val .s.arkea.com
  cname: 
  # -- requestRouting prend la priorité sur trafficShifting. Si les 2 sont désactivés, toutes les requêtes vont sur le premiers elements de `image.tags`<br>
  # permet d'activer le canary
  # se referer à values.yaml directement
  # @default -- `requestRouting.enabled: false`
  requestRouting:
    enabled: false
    routes:
      # -- tag de la version à gérer
    - tag: latest
      # -- []HTTPMatchRequest https://istio.io/latest/docs/reference/config/networking/virtual-service/#HTTPMatchRequest
      match: #
      - headers:
          end-user:
            exact: jason
    - tag: test
      match:
      - headers:
          end-user:
            exact: foobar
  # -- trafficShifting permet d'activer le routage de traffic par poids
  # @default -- `trafficShifting.enable: false`
  trafficShifting:
    enabled: false
    # -- tableau de map
    destinations:
        # -- tag de la version à gerer
      - tag: latest
        # -- poids à associer. ça ne sera qu'un pourcentage que si la somme de toutes les weights vaut 100
        weight: 25
        # -- tag de la version à gerer
      - tag: test
        # -- poids à associer. ça ne sera qu'un pourcentage que si la somme de toutes les weights vaut 100
        weight: 75

